### 前言

在前面的章节中，我们学习了用`pygame`来创建动画的一些基础知识，也研究了一些动画、文字、声音等元素以及对鼠标和键盘响应的处理，这一次我们开始进入实战操作，通过对一个“小迷宫”游戏的开发来逐步掌握`pygame`在二维游戏领域的强大功能。

### 游戏思路

先来看一下我们游戏的最终形态：

![1](D:\思维导图\1-1569574441174.gif)

这个游戏相信有不少同学都玩过，主要玩法：游戏最开始给玩家显示5-10秒的记忆时间，而后全部用白色方块覆盖，玩家需要通过瞬间记忆能力找到相同的两个图标，当然这中间可以试错，全部找完用时越短说明玩家的瞬间记忆能力越强。

下面将开发这款小游戏的步骤列举如下：

1. 集齐图标。这些图标可以在各个免费图标网站下载，当然同学们可以依据自己的爱好制作图标，为了显示美观，将图标设计为正方形会是个好主意。
2. 程序加载图标。同学们可以将收集齐的图标放入同一个文件夹下，为方便程序设计，建议可将图标按某种规律命名，比如我这里用的是`fruit1`、`fruit2`等等，这样子就可以充分利用循环体来加载。
3. 绘制背景，在界面上设计好各个图标的位置。二维游戏的设计肯定离不开平面坐标系，在前面章节我们已经研究了`pygame`的坐标系统，这里需要用到嵌套循环还计算各个图标位置的摆放。
4. 处理鼠标点击事件。在前面章节我们已经学习了如何获取鼠标点击的位置，通过第3步，我们可以存储各个图标的实际位置范围，以便于检测用户鼠标点击时，是位于哪一个图标上。
5. 匹配图标。由于游戏是两个图标进行匹配，所以程序需要记忆两次点击的图标及位置，并进行比对，如果一致，则显示两个图标，否则将两个已经点开的不同图标均用白色方块覆盖。
6. 记时功能。玩游戏最重要的是有一个标准，对于这个小游戏来说，匹配完所有的图标当然是一个标准，但如果加上记时功能，则对于游戏玩家更具挑战性，同时可以挑战自己的瞬间记忆能力。
7. 排名功能。在游戏结束的时候可以弹出对话框，让用户输入名字，并保存用户的成绩，可以只取前三名。

下面进入分步讲解：

### 图标的收集

本小程序所用的图标在`easyicon.net`这个网站下载，通过输入`fruit`关键字，可以搜索相应的水果图标来下载：

![22](D:\思维导图\22.PNG)

当然同学们可以利用自己熟悉的各种绘图软件来制作图标，甚至可以利用班集同学们的大头贴来制作一个小游戏（前提当然得征得大家的同意才好哦）。

### 程序加载图标

为了加载图标，我们首先要知道图标所在的路径，在这里，可在当前程序同目录下建立一个`images`的文件夹，将所有图标文件编号后放在其中，可用下面代码加载：

```python
# 将图标加载到全局列表中
lstIcon = []
def loadIcon():
    for i in range(1, 19):
        iconname = 'image/fruit'+str(i) + '.png'
        tmpimg = pygame.image.load(iconname)
        tmpimg = pygame.transform.smoothscale(tmpimg, (40,40))
        lstIcon.append(tmpimg)
        lstIcon.append(tmpimg)
```

需要注意，我们的小游戏界面上设计的是6X6个小方格，所以只需要18个图标即可，因此在将图标文件添加到全局变量中时，要将每一个图标文件添加两次，上述代码中的`pygame.transform.smoothscale`函数是将加载的图标按我们的需求进行缩放。

当然在加载完成后，需要将所加载的全部图标进行随机排列：

```python
loadIcon()
random.shuffle(lstIcon)#将图标排列随机化
```

### 计算位置及绘制背景

为了方便程序设计，这里使用了二维数组，`python`中的二维数组比较简单，下面一行代码即可创建一个全部元素为0的二维数组：

```python
In [0]: lstBlockRect = [[0 for i in range(m)] for j in range(n)]
In [1]: lstBlockRect
Out[1]: 
[[0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0],
 [0, 0, 0, 0, 0, 0]]
```

游戏界面上每个小方块的坐标都要计算，有关图形的`rect`部分内容在前面章节有讲到，不熟悉的同学可以回看一下，下面代码演示了如何计算每一个小方块的`rect`，并将其加入刚才创建的二维数组中去：

```python
def generatePos():
    for i in range(m):
        for j in range(n):
            lstBlockRect[i][j] = (70+i*(W+30),90+j*(W+30), W, W)
generatePos() # 生成所有图标的位置数据
```

为了更好地绘制背景及覆盖方块，需要创建一个***伴随二维数组***，该数组与所有的图标一一对应，作用是标记当前图标是否显示，若显示，则相应位置设置为1，否则设置为0。当标记位为1的时候，程序将绘制图标，为0的时候，程序将绘制白色方块，以下代码完成该功能：

```python
# 绘制背景
def drawBackGround():
    curSurface.fill(NAVYBLUE)
    for i in range(m):
        for j in range(n):
            if lstBlockFlag[i][j] == 0: # 标记位为零，则绘制白色方块
                pygame.draw.rect(curSurf, WHITE, lstBlockRect[i][j])
            else:
                curSurf.blit(lstIcon[i*6+j], (70+i*(W+30),90+j*(W+30), W, W))
```

### 处理鼠标点击

上一章中我们已经学习了如何获取鼠标的点击位置，根据点击获取的数据，来查找当前点击位于哪一个方块上，当然，这里我们用方块所在的列与行来标识位置。

```python
# 根据用户点击鼠标位置查找到相应的图标
def findBlockByPos(mouse_x, mouse_y):
    for i in range(m):
        for j in range(n):
            if mouse_x > lRect[i][j][0] and mouse_x <= lRect[i][j][0] + W:
                if mouse_y > lRect[i][j][1] and mouse_y <= lRect[i][j][1] + W:
                    return (i,j)
    return(-1,-1)
```

上述函数可以根据鼠标点击的位置找到相应的方块，如果点击的位置不在方块上，那就返回一个`(-1,-1)`来标识。

在找到鼠标点击的方块位置后，在主循环体中根据玩家点击次数的奇偶性来对**伴随数组**进行标记修改，下面代码位于循环体内：

```python
curIcon = findBlockByPos(mouse_x, mouse_y)
if curIcon != (-1,-1) and  lstBlockFlag != lstBlockFlag_OVER:
    g_ClickCount += 1
    # 修改被击点的图标标志
    lstBlockFlag[curIcon[0]][curIcon[1]] = 1 # 修改伴随数组标志
    indx_icon = curIcon[0]*n+curIcon[1] #根据行列计算当前坐标位于图标数组的位置
    if g_ClickCount % 2 == 1: # 奇数点击，记录第一次
        first_ClickIcon = [lstIcon[indx_icon], curIcon]
    else: # 偶数点击，记录第二次
        second_ClickIcon = [lstIcon[indx_icon], curIcon]
```

### 小结

在这一章，主要学习了如何对一个游戏进行制作的基本思路，研究了图标的加载，二维数组的创建，界面坐标的计算，以及根据鼠标点击的位置对界面元素的查找，这都是制作一个游戏最基本的功能，同学们要好好体会，本章就先到这里，剩下的部分将在下一章进行详细讲述。